Question 1:
Did a sort to sort both strings first, and then use a while loop to create a version of the second string based on first_str's substrings. Sorted() is used, and is the predominant Time complexity uses, thus the efficiency is O(nlog(n)). As for the space efficiency, I have created two lists that are sorted, and a sub_first_string list that gets appended. Since only one list gets appended, the space efficiency is O(n).

Question 2:
Created a helper script that checks whether the substring of the original string is a palindrome. With the while loop on the helper function, and the for loop to loop in combination of the strings, the time efficiency is O(n^2).

For SearchForPalindrome, it has a for loop that consistently changing numbers for "start"and "end". That is O(2), and for question2 method, extra storage was stored for "length","i", and "result". It adds up the space complexity to be O(1).  

Question 3:
It goes from the first dictionary, and keeps up climbing to the next list until it hits an entire circle. It then validates whether the distance would be better than the the alternatives. With 2 for loops, the time efficiency is also O(n^2).

For Space complexity, it uses shortes_path as dictionary to set, add function, and checkec_vertex to Set(). They are all depended on how many keys are in the dictionary, which shows the efficiency to be O(n).

Question 4:
Created helperfunction for TreeLeveOutput to determine what the level the child is in, and also provide the node above it. The question 4 focuses on checking between which level is higher, and outout the ancestor of the higher node. TreeLeveLOutput is a recursive function with one for loop.It has a O(n^2) of efficiency. The actual question 4 does not have any itertion, so the efficiency is also O(n^2).

FOr space efficiency, no space is used at question4 method, but spaces where saved as the value i. The value i is integer that gets changed consistently, so the efficiency is O(1).

Question 5:
Question 5 uses classes of Node and LinkedList to create linkedlist array. It first creates individual objects on Node(), then uses the Linkedlist to connect them all together. It then does tree climbing twice: the first time is to find out how many objects there are, and the second one to find out what is the correct object according to the list. It uses two while loops, which shows the efficiency to be O(n^2).

For Space efficiency, it was saved to create 5 nodes class, and append them in a linked list of LInkedLIst(node). n node was created, and a list of 5 nodes were created for linked list. Within the function question 5, it stores ll in "current" and "next_current". This shows the space efficiency to be O(n).
